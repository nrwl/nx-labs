"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.interpolateArgsIntoCommand = exports.LARGE_BUFFER = void 0;
const child_process_1 = require("child_process");
const path = require("path");
const yargsParser = require("yargs-parser");
const npm_run_path_1 = require("npm-run-path");
const chalk = require("chalk");
const native_1 = require("../../native");
const child_process_2 = require("../../utils/child-process");
exports.LARGE_BUFFER = 1024 * 1000000;
async function loadEnvVars(path) {
    if (path) {
        const result = (await Promise.resolve().then(() => require('dotenv'))).config({ path });
        if (result.error) {
            throw result.error;
        }
    }
    else {
        try {
            (await Promise.resolve().then(() => require('dotenv'))).config();
        }
        catch { }
    }
}
const propKeys = [
    'command',
    'commands',
    'color',
    'parallel',
    'readyWhen',
    'cwd',
    'args',
    'envFile',
];
async function default_1(options, context) {
    await loadEnvVars(options.envFile);
    const normalized = normalizeOptions(options);
    if (options.readyWhen && !options.parallel) {
        throw new Error('ERROR: Bad executor config for run-commands - "readyWhen" can only be used when "parallel=true".');
    }
    if (options.commands.find((c) => c.prefix || c.color || c.bgColor) &&
        !options.parallel) {
        throw new Error('ERROR: Bad executor config for run-commands - "prefix", "color" and "bgColor" can only be set when "parallel=true".');
    }
    try {
        const success = options.parallel
            ? await runInParallel(normalized, context)
            : await runSerially(normalized, context);
        return { success };
    }
    catch (e) {
        if (process.env.NX_VERBOSE_LOGGING === 'true') {
            console.error(e);
        }
        throw new Error(`ERROR: Something went wrong in run-commands - ${e.message}`);
    }
}
exports.default = default_1;
async function runInParallel(options, context) {
    const procs = options.commands.map((c) => createProcess(c, options.readyWhen, options.color, calculateCwd(options.cwd, context), options.env ?? {}, true).then((result) => ({
        result,
        command: c.command,
    })));
    if (options.readyWhen) {
        const r = await Promise.race(procs);
        if (!r.result) {
            process.stderr.write(`Warning: command "${r.command}" exited with non-zero status code`);
            return false;
        }
        else {
            return true;
        }
    }
    else {
        const r = await Promise.all(procs);
        const failed = r.filter((v) => !v.result);
        if (failed.length > 0) {
            failed.forEach((f) => {
                process.stderr.write(`Warning: command "${f.command}" exited with non-zero status code`);
            });
            return false;
        }
        else {
            return true;
        }
    }
}
function normalizeOptions(options) {
    if (options.command) {
        options.commands = [{ command: options.command }];
        options.parallel = !!options.readyWhen;
    }
    else {
        options.commands = options.commands.map((c) => typeof c === 'string' ? { command: c } : c);
    }
    if (options.args && Array.isArray(options.args)) {
        options.args = options.args.join(' ');
    }
    options.parsedArgs = parseArgs(options, options.args);
    options.commands.forEach((c) => {
        c.command = interpolateArgsIntoCommand(c.command, options, c.forwardAllArgs ?? true);
    });
    return options;
}
async function runSerially(options, context) {
    for (const c of options.commands) {
        const success = await createProcess(c, undefined, options.color, calculateCwd(options.cwd, context), options.env ?? {}, false);
        if (!success) {
            process.stderr.write(`Warning: command "${c.command}" exited with non-zero status code`);
            return false;
        }
    }
    return true;
}
async function createProcess(commandConfig, readyWhen, color, cwd, env, isParallel) {
    env = processEnv(color, cwd, env);
    // The rust runCommand is always a tty, so it will not look nice in parallel and if we need prefixes
    // currently does not work properly in windows
    if (process.env.NX_NATIVE_COMMAND_RUNNER !== 'false' &&
        process.stdout.isTTY &&
        !commandConfig.prefix &&
        !isParallel) {
        const cp = new child_process_2.PseudoTtyProcess((0, native_1.runCommand)(commandConfig.command, cwd, env));
        return new Promise((res) => {
            cp.onOutput((output) => {
                if (readyWhen && output.indexOf(readyWhen) > -1) {
                    res(true);
                }
            });
            cp.onExit((code) => {
                if (code === 0) {
                    res(true);
                }
                else if (code >= 128) {
                    process.exit(code);
                }
                else {
                    res(false);
                }
            });
        });
    }
    return nodeProcess(commandConfig, color, cwd, env, readyWhen);
}
function nodeProcess(commandConfig, color, cwd, env, readyWhen) {
    return new Promise((res) => {
        const childProcess = (0, child_process_1.exec)(commandConfig.command, {
            maxBuffer: exports.LARGE_BUFFER,
            env,
            cwd,
        });
        /**
         * Ensure the child process is killed when the parent exits
         */
        const processExitListener = (signal) => childProcess.kill(signal);
        process.on('exit', processExitListener);
        process.on('SIGTERM', processExitListener);
        process.on('SIGINT', processExitListener);
        process.on('SIGQUIT', processExitListener);
        childProcess.stdout.on('data', (data) => {
            process.stdout.write(addColorAndPrefix(data, commandConfig));
            if (readyWhen && data.toString().indexOf(readyWhen) > -1) {
                res(true);
            }
        });
        childProcess.stderr.on('data', (err) => {
            process.stderr.write(addColorAndPrefix(err, commandConfig));
            if (readyWhen && err.toString().indexOf(readyWhen) > -1) {
                res(true);
            }
        });
        childProcess.on('error', (err) => {
            process.stderr.write(addColorAndPrefix(err.toString(), commandConfig));
            res(false);
        });
        childProcess.on('exit', (code) => {
            if (!readyWhen) {
                res(code === 0);
            }
        });
    });
}
function addColorAndPrefix(out, config) {
    if (config.prefix) {
        out = out
            .split('\n')
            .map((l) => l.trim().length > 0 ? `${chalk.bold(config.prefix)} ${l}` : l)
            .join('\n');
    }
    if (config.color && chalk[config.color]) {
        out = chalk[config.color](out);
    }
    if (config.bgColor && chalk[config.bgColor]) {
        out = chalk[config.bgColor](out);
    }
    return out;
}
function calculateCwd(cwd, context) {
    if (!cwd)
        return context.root;
    if (path.isAbsolute(cwd))
        return cwd;
    return path.join(context.root, cwd);
}
function processEnv(color, cwd, env) {
    const res = {
        ...process.env,
        ...(0, npm_run_path_1.env)({ cwd: cwd ?? process.cwd() }),
        ...env,
    };
    if (color) {
        res.FORCE_COLOR = `${color}`;
    }
    return res;
}
function interpolateArgsIntoCommand(command, opts, forwardAllArgs) {
    if (command.indexOf('{args.') > -1) {
        const regex = /{args\.([^}]+)}/g;
        return command.replace(regex, (_, group) => opts.parsedArgs[group] !== undefined ? opts.parsedArgs[group] : '');
    }
    else if (forwardAllArgs) {
        return `${command}${opts.args ? ' ' + opts.args : ''}${opts.__unparsed__.length > 0 ? ' ' + opts.__unparsed__.join(' ') : ''}`;
    }
    else {
        return command;
    }
}
exports.interpolateArgsIntoCommand = interpolateArgsIntoCommand;
function parseArgs(options, args) {
    if (!args) {
        const unknownOptionsTreatedAsArgs = Object.keys(options)
            .filter((p) => propKeys.indexOf(p) === -1)
            .reduce((m, c) => ((m[c] = options[c]), m), {});
        const unparsedCommandArgs = yargsParser(options.__unparsed__, {
            configuration: {
                'parse-numbers': false,
                'parse-positional-numbers': false,
                'dot-notation': false,
            },
        });
        return { ...unknownOptionsTreatedAsArgs, ...unparsedCommandArgs };
    }
    return yargsParser(args.replace(/(^"|"$)/g, ''), {
        configuration: { 'camel-case-expansion': false },
    });
}
