"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultPlugins = exports.unregisterPluginTSTranspiler = exports.registerPluginTSTranspiler = exports.resolveLocalNxPlugin = exports.readPluginPackageJson = exports.isNxPluginV1 = exports.isNxPluginV2 = exports.ensurePluginIsV2 = exports.loadNxPlugins = exports.loadNxPluginAsync = exports.getPluginPathAndName = exports.nxPluginCache = void 0;
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const path = require("path");
const workspaces_1 = require("../config/workspaces");
const workspace_root_1 = require("./workspace-root");
const fileutils_1 = require("../utils/fileutils");
const package_json_1 = require("./package-json");
const register_1 = require("../plugins/js/utils/register");
const logger_1 = require("./logger");
const find_project_for_path_1 = require("../project-graph/utils/find-project-for-path");
const path_1 = require("./path");
const path_2 = require("path");
const installation_directory_1 = require("./installation-directory");
const typescript_1 = require("../plugins/js/utils/typescript");
const nx_json_1 = require("../config/nx-json");
const globs_1 = require("./globs");
const angular_json_1 = require("../adapter/angular-json");
const package_json_workspaces_1 = require("../plugins/package-json-workspaces");
const project_json_1 = require("../plugins/project-json/build-nodes/project-json");
const package_json_next_to_project_json_1 = require("../plugins/project-json/build-nodes/package-json-next-to-project-json");
const retrieve_workspace_files_1 = require("../project-graph/utils/retrieve-workspace-files");
const target_defaults_plugin_1 = require("../plugins/target-defaults/target-defaults-plugin");
tslib_1.__exportStar(require("./nx-plugin.deprecated"), exports);
// Short lived cache (cleared between cmd runs)
// holding resolved nx plugin objects.
// Allows loadNxPlugins to be called multiple times w/o
// executing resolution mulitple times.
exports.nxPluginCache = new Map();
function getPluginPathAndName(moduleName, paths, projects, root) {
    let pluginPath;
    try {
        pluginPath = require.resolve(moduleName, {
            paths,
        });
    }
    catch (e) {
        if (e.code === 'MODULE_NOT_FOUND') {
            const plugin = resolveLocalNxPlugin(moduleName, (0, nx_json_1.readNxJson)(root), projects, root);
            if (plugin) {
                const main = readPluginMainFromProjectConfiguration(plugin.projectConfig);
                pluginPath = main ? path.join(root, main) : plugin.path;
            }
            else {
                logger_1.logger.error(`Plugin listed in \`nx.json\` not found: ${moduleName}`);
                throw e;
            }
        }
        else {
            throw e;
        }
    }
    const packageJsonPath = path.join(pluginPath, 'package.json');
    const extension = path.extname(pluginPath);
    // Register the ts-transpiler if we are pointing to a
    // plain ts file that's not part of a plugin project
    if (extension === '.ts' && !tsNodeAndPathsUnregisterCallback) {
        registerPluginTSTranspiler();
    }
    const { name } = !['.ts', '.js'].some((x) => x === extension) && // Not trying to point to a ts or js file
        (0, fs_1.existsSync)(packageJsonPath) // plugin has a package.json
        ? (0, fileutils_1.readJsonFile)(packageJsonPath) // read name from package.json
        : { name: moduleName };
    return { pluginPath, name };
}
exports.getPluginPathAndName = getPluginPathAndName;
async function loadNxPluginAsync(pluginConfiguration, paths, projects, root) {
    const { plugin: moduleName, options } = typeof pluginConfiguration === 'object'
        ? pluginConfiguration
        : { plugin: pluginConfiguration, options: undefined };
    let pluginModule = exports.nxPluginCache.get(moduleName);
    if (pluginModule) {
        return { plugin: pluginModule, options };
    }
    performance.mark(`Load Nx Plugin: ${moduleName} - start`);
    let { pluginPath, name } = await getPluginPathAndName(moduleName, paths, projects, root);
    const plugin = ensurePluginIsV2((await Promise.resolve(`${pluginPath}`).then(s => require(s))));
    plugin.name ??= name;
    exports.nxPluginCache.set(moduleName, plugin);
    performance.mark(`Load Nx Plugin: ${moduleName} - end`);
    performance.measure(`Load Nx Plugin: ${moduleName}`, `Load Nx Plugin: ${moduleName} - start`, `Load Nx Plugin: ${moduleName} - end`);
    return { plugin, options };
}
exports.loadNxPluginAsync = loadNxPluginAsync;
async function loadNxPlugins(plugins, paths = (0, installation_directory_1.getNxRequirePaths)(), root = workspace_root_1.workspaceRoot, projects) {
    const result = [
        { plugin: package_json_next_to_project_json_1.PackageJsonProjectsNextToProjectJsonPlugin },
    ];
    plugins ??= [];
    // When loading plugins for `createNodes`, we don't know what projects exist yet.
    // Try resolving plugins
    for (const plugin of plugins) {
        try {
            require.resolve(typeof plugin === 'string' ? plugin : plugin.plugin);
        }
        catch {
            // If a plugin cannot be resolved, we will need projects to resolve it
            projects ??= await (0, retrieve_workspace_files_1.retrieveProjectConfigurationsWithoutPluginInference)(root);
            break;
        }
    }
    for (const plugin of plugins) {
        result.push(await loadNxPluginAsync(plugin, paths, projects, root));
    }
    // We push the nx core node plugins onto the end, s.t. it overwrites any other plugins
    result.push(...(await getDefaultPlugins(root)));
    return result;
}
exports.loadNxPlugins = loadNxPlugins;
function ensurePluginIsV2(plugin) {
    if (isNxPluginV2(plugin)) {
        return plugin;
    }
    if (isNxPluginV1(plugin) && plugin.projectFilePatterns) {
        return {
            ...plugin,
            createNodes: [
                `*/**/${(0, globs_1.combineGlobPatterns)(plugin.projectFilePatterns)}`,
                (configFilePath) => {
                    const root = (0, path_2.dirname)(configFilePath);
                    return {
                        projects: {
                            [root]: {
                                name: (0, workspaces_1.toProjectName)(configFilePath),
                                root,
                                targets: plugin.registerProjectTargets?.(configFilePath),
                            },
                        },
                    };
                },
            ],
        };
    }
    return plugin;
}
exports.ensurePluginIsV2 = ensurePluginIsV2;
function isNxPluginV2(plugin) {
    return 'createNodes' in plugin || 'createDependencies' in plugin;
}
exports.isNxPluginV2 = isNxPluginV2;
function isNxPluginV1(plugin) {
    return 'processProjectGraph' in plugin || 'projectFilePatterns' in plugin;
}
exports.isNxPluginV1 = isNxPluginV1;
function readPluginPackageJson(pluginName, projects, paths = (0, installation_directory_1.getNxRequirePaths)()) {
    try {
        const result = (0, package_json_1.readModulePackageJsonWithoutFallbacks)(pluginName, paths);
        return {
            json: result.packageJson,
            path: result.path,
        };
    }
    catch (e) {
        if (e.code === 'MODULE_NOT_FOUND') {
            const nxJson = (0, nx_json_1.readNxJson)();
            const localPluginPath = resolveLocalNxPlugin(pluginName, nxJson, projects);
            if (localPluginPath) {
                const localPluginPackageJson = path.join(localPluginPath.path, 'package.json');
                return {
                    path: localPluginPackageJson,
                    json: (0, fileutils_1.readJsonFile)(localPluginPackageJson),
                };
            }
        }
        throw e;
    }
}
exports.readPluginPackageJson = readPluginPackageJson;
/**
 * Builds a plugin package and returns the path to output
 * @param importPath What is the import path that refers to a potential plugin?
 * @returns The path to the built plugin, or null if it doesn't exist
 */
const localPluginCache = {};
function resolveLocalNxPlugin(importPath, nxJsonConfiguration, projects, root = workspace_root_1.workspaceRoot) {
    localPluginCache[importPath] ??= lookupLocalPlugin(importPath, nxJsonConfiguration, projects, root);
    return localPluginCache[importPath];
}
exports.resolveLocalNxPlugin = resolveLocalNxPlugin;
let tsNodeAndPathsUnregisterCallback = undefined;
/**
 * Register swc-node or ts-node if they are not currently registered
 * with some default settings which work well for Nx plugins.
 */
function registerPluginTSTranspiler() {
    if (!tsNodeAndPathsUnregisterCallback) {
        // nx-ignore-next-line
        const ts = require('typescript');
        // Get the first tsconfig that matches the allowed set
        const tsConfigName = [
            (0, path_2.join)(workspace_root_1.workspaceRoot, 'tsconfig.base.json'),
            (0, path_2.join)(workspace_root_1.workspaceRoot, 'tsconfig.json'),
        ].find((x) => (0, fs_1.existsSync)(x));
        const tsConfig = tsConfigName
            ? (0, typescript_1.readTsConfig)(tsConfigName)
            : {};
        const unregisterTsConfigPaths = (0, register_1.registerTsConfigPaths)(tsConfigName);
        const unregisterTranspiler = (0, register_1.registerTranspiler)({
            experimentalDecorators: true,
            emitDecoratorMetadata: true,
            ...tsConfig.options,
        });
        tsNodeAndPathsUnregisterCallback = () => {
            unregisterTsConfigPaths();
            unregisterTranspiler();
        };
    }
}
exports.registerPluginTSTranspiler = registerPluginTSTranspiler;
/**
 * Unregister the ts-node transpiler if it is registered
 */
function unregisterPluginTSTranspiler() {
    if (tsNodeAndPathsUnregisterCallback) {
        tsNodeAndPathsUnregisterCallback();
        tsNodeAndPathsUnregisterCallback = undefined;
    }
}
exports.unregisterPluginTSTranspiler = unregisterPluginTSTranspiler;
function lookupLocalPlugin(importPath, nxJsonConfiguration, projects, root = workspace_root_1.workspaceRoot) {
    const plugin = findNxProjectForImportPath(importPath, projects, root);
    if (!plugin) {
        return null;
    }
    if (!tsNodeAndPathsUnregisterCallback) {
        registerPluginTSTranspiler();
    }
    const projectConfig = projects[plugin];
    return { path: path.join(root, projectConfig.root), projectConfig };
}
function findNxProjectForImportPath(importPath, projects, root = workspace_root_1.workspaceRoot) {
    const tsConfigPaths = readTsConfigPaths(root);
    const possiblePaths = tsConfigPaths[importPath]?.map((p) => (0, path_1.normalizePath)(path.relative(root, path.join(root, p))));
    if (possiblePaths?.length) {
        const projectRootMappings = (0, find_project_for_path_1.createProjectRootMappingsFromProjectConfigurations)(projects);
        for (const tsConfigPath of possiblePaths) {
            const nxProject = (0, find_project_for_path_1.findProjectForPath)(tsConfigPath, projectRootMappings);
            if (nxProject) {
                return nxProject;
            }
        }
        if (process.env.NX_VERBOSE_LOGGING) {
            console.log('Unable to find local plugin', possiblePaths, projectRootMappings);
        }
        throw new Error('Unable to resolve local plugin with import path ' + importPath);
    }
}
let tsconfigPaths;
function readTsConfigPaths(root = workspace_root_1.workspaceRoot) {
    if (!tsconfigPaths) {
        const tsconfigPath = ['tsconfig.base.json', 'tsconfig.json']
            .map((x) => path.join(root, x))
            .filter((x) => (0, fs_1.existsSync)(x))[0];
        if (!tsconfigPath) {
            throw new Error('unable to find tsconfig.base.json or tsconfig.json');
        }
        const { compilerOptions } = (0, fileutils_1.readJsonFile)(tsconfigPath);
        tsconfigPaths = compilerOptions?.paths;
    }
    return tsconfigPaths ?? {};
}
function readPluginMainFromProjectConfiguration(plugin) {
    const { main } = Object.values(plugin.targets).find((x) => [
        '@nx/js:tsc',
        '@nrwl/js:tsc',
        '@nx/js:swc',
        '@nrwl/js:swc',
        '@nx/node:package',
        '@nrwl/node:package',
    ].includes(x.executor))?.options ||
        plugin.targets?.build?.options ||
        {};
    return main;
}
async function getDefaultPlugins(root) {
    const plugins = [
        await Promise.resolve().then(() => require('../plugins/js')),
        target_defaults_plugin_1.TargetDefaultsPlugin,
        ...((0, angular_json_1.shouldMergeAngularProjects)(root, false)
            ? [
                await Promise.resolve().then(() => require('../adapter/angular-json')).then((m) => m.NxAngularJsonPlugin),
            ]
            : []),
        (0, package_json_workspaces_1.getNxPackageJsonWorkspacesPlugin)(root),
        project_json_1.ProjectJsonProjectsPlugin,
    ];
    return plugins.map((p) => ({
        plugin: p,
    }));
}
exports.getDefaultPlugins = getDefaultPlugins;
