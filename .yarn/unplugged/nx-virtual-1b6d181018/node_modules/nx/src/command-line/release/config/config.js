"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleNxReleaseConfigError = exports.createNxReleaseConfig = exports.IMPLICIT_DEFAULT_RELEASE_GROUP = void 0;
const devkit_exports_1 = require("../../../devkit-exports");
const find_matching_projects_1 = require("../../../utils/find-matching-projects");
const resolve_nx_json_error_message_1 = require("../utils/resolve-nx-json-error-message");
exports.IMPLICIT_DEFAULT_RELEASE_GROUP = '__default__';
// Apply default configuration to any optional user configuration and handle known errors
async function createNxReleaseConfig(projectGraph, userConfig = {}) {
    if (userConfig.projects && userConfig.groups) {
        return {
            error: {
                code: 'PROJECTS_AND_GROUPS_DEFINED',
                data: {},
            },
            nxReleaseConfig: null,
        };
    }
    if (hasInvalidGitConfig(userConfig)) {
        return {
            error: {
                code: 'GLOBAL_GIT_CONFIG_MIXED_WITH_GRANULAR_GIT_CONFIG',
                data: {},
            },
            nxReleaseConfig: null,
        };
    }
    if (hasInvalidConventionalCommitsConfig(userConfig)) {
        return {
            error: {
                code: 'CONVENTIONAL_COMMITS_SHORTHAND_MIXED_WITH_OVERLAPPING_GENERATOR_OPTIONS',
                data: {},
            },
            nxReleaseConfig: null,
        };
    }
    const gitDefaults = {
        commit: false,
        commitMessage: 'chore(release): publish {version}',
        commitArgs: '',
        tag: false,
        tagMessage: '',
        tagArgs: '',
        stageChanges: false,
    };
    const versionGitDefaults = {
        ...gitDefaults,
        stageChanges: true,
    };
    const changelogGitDefaults = {
        ...gitDefaults,
        commit: true,
        tag: true,
    };
    const defaultFixedReleaseTagPattern = 'v{version}';
    const defaultIndependentReleaseTagPattern = '{projectName}@{version}';
    const workspaceProjectsRelationship = userConfig.projectsRelationship || 'fixed';
    const defaultGeneratorOptions = userConfig.version?.conventionalCommits
        ? {
            currentVersionResolver: 'git-tag',
            specifierSource: 'conventional-commits',
        }
        : {};
    const userGroups = Object.values(userConfig.groups ?? {});
    const disableWorkspaceChangelog = userGroups.length > 1 ||
        (userGroups.length === 1 &&
            userGroups[0].projectsRelationship === 'independent') ||
        (userConfig.projectsRelationship === 'independent' &&
            !userGroups.some((g) => g.projectsRelationship === 'fixed'));
    const WORKSPACE_DEFAULTS = {
        // By default all projects in all groups are released together
        projectsRelationship: workspaceProjectsRelationship,
        git: gitDefaults,
        version: {
            git: versionGitDefaults,
            conventionalCommits: userConfig.version?.conventionalCommits || false,
            generator: '@nx/js:release-version',
            generatorOptions: defaultGeneratorOptions,
        },
        changelog: {
            git: changelogGitDefaults,
            workspaceChangelog: disableWorkspaceChangelog
                ? false
                : {
                    createRelease: false,
                    entryWhenNoChanges: 'This was a version bump only, there were no code changes.',
                    file: '{workspaceRoot}/CHANGELOG.md',
                    renderer: 'nx/release/changelog-renderer',
                    renderOptions: {
                        authors: true,
                        commitReferences: true,
                        versionTitleDate: true,
                    },
                },
            // For projectChangelogs if the user has set any changelog config at all, then use one set of defaults, otherwise default to false for the whole feature
            projectChangelogs: userConfig.changelog?.projectChangelogs
                ? {
                    createRelease: false,
                    file: '{projectRoot}/CHANGELOG.md',
                    entryWhenNoChanges: 'This was a version bump only for {projectName} to align it with other projects, there were no code changes.',
                    renderer: 'nx/release/changelog-renderer',
                    renderOptions: {
                        authors: true,
                        commitReferences: true,
                        versionTitleDate: true,
                    },
                }
                : false,
            automaticFromRef: false,
        },
        releaseTagPattern: userConfig.releaseTagPattern ||
            // The appropriate default releaseTagPattern is dependent upon the projectRelationships
            (workspaceProjectsRelationship === 'independent'
                ? defaultIndependentReleaseTagPattern
                : defaultFixedReleaseTagPattern),
    };
    const groupProjectsRelationship = userConfig.projectsRelationship || WORKSPACE_DEFAULTS.projectsRelationship;
    const GROUP_DEFAULTS = {
        projectsRelationship: groupProjectsRelationship,
        version: {
            conventionalCommits: false,
            generator: '@nx/js:release-version',
            generatorOptions: {},
        },
        changelog: {
            createRelease: false,
            entryWhenNoChanges: 'This was a version bump only for {projectName} to align it with other projects, there were no code changes.',
            file: '{projectRoot}/CHANGELOG.md',
            renderer: 'nx/release/changelog-renderer',
            renderOptions: {
                authors: true,
                commitReferences: true,
                versionTitleDate: true,
            },
        },
        releaseTagPattern: 
        // The appropriate group default releaseTagPattern is dependent upon the projectRelationships
        groupProjectsRelationship === 'independent'
            ? defaultIndependentReleaseTagPattern
            : WORKSPACE_DEFAULTS.releaseTagPattern,
    };
    /**
     * We first process root level config and apply defaults, so that we know how to handle the group level
     * overrides, if applicable.
     */
    const rootGitConfig = deepMergeDefaults([WORKSPACE_DEFAULTS.git], userConfig.git);
    const rootVersionConfig = deepMergeDefaults([
        WORKSPACE_DEFAULTS.version,
        // Merge in the git defaults from the top level
        { git: versionGitDefaults },
        {
            git: userConfig.git,
        },
    ], userConfig.version);
    if (userConfig.changelog?.workspaceChangelog) {
        userConfig.changelog.workspaceChangelog = normalizeTrueToEmptyObject(userConfig.changelog.workspaceChangelog);
    }
    if (userConfig.changelog?.projectChangelogs) {
        userConfig.changelog.projectChangelogs = normalizeTrueToEmptyObject(userConfig.changelog.projectChangelogs);
    }
    const rootChangelogConfig = deepMergeDefaults([
        WORKSPACE_DEFAULTS.changelog,
        // Merge in the git defaults from the top level
        { git: changelogGitDefaults },
        {
            git: userConfig.git,
        },
    ], normalizeTrueToEmptyObject(userConfig.changelog));
    // git configuration is not supported at the group level, only the root/command level
    const rootVersionWithoutGit = { ...rootVersionConfig };
    delete rootVersionWithoutGit.git;
    // Apply conventionalCommits shorthand to the final group defaults if explicitly configured in the original user config
    if (userConfig.version?.conventionalCommits === true) {
        rootVersionWithoutGit.generatorOptions = {
            ...rootVersionWithoutGit.generatorOptions,
            currentVersionResolver: 'git-tag',
            specifierSource: 'conventional-commits',
        };
    }
    if (userConfig.version?.conventionalCommits === false) {
        delete rootVersionWithoutGit.generatorOptions.currentVersionResolver;
        delete rootVersionWithoutGit.generatorOptions.specifierSource;
    }
    const groups = userConfig.groups && Object.keys(userConfig.groups).length
        ? ensureProjectsConfigIsArray(userConfig.groups)
        : /**
           * No user specified release groups, so we treat all projects (or any any user-defined subset via the top level "projects" property)
           * as being in one release group together in which the projects are released in lock step.
           */
            {
                [exports.IMPLICIT_DEFAULT_RELEASE_GROUP]: {
                    projectsRelationship: GROUP_DEFAULTS.projectsRelationship,
                    projects: userConfig.projects
                        ? // user-defined top level "projects" config takes priority if set
                            (0, find_matching_projects_1.findMatchingProjects)(ensureArray(userConfig.projects), projectGraph.nodes)
                        : // default to all library projects in the workspace
                            (0, find_matching_projects_1.findMatchingProjects)(['*'], projectGraph.nodes).filter((project) => projectGraph.nodes[project].type === 'lib'),
                    /**
                     * For properties which are overriding config at the root, we use the root level config as the
                     * default values to merge with so that the group that matches a specific project will always
                     * be the valid source of truth for that type of config.
                     */
                    version: deepMergeDefaults([GROUP_DEFAULTS.version], rootVersionWithoutGit),
                    // If the user has set something custom for releaseTagPattern at the top level, respect it for the implicit default group
                    releaseTagPattern: userConfig.releaseTagPattern || GROUP_DEFAULTS.releaseTagPattern,
                    // Directly inherit the root level config for projectChangelogs, if set
                    changelog: rootChangelogConfig.projectChangelogs || false,
                },
            };
    /**
     * Resolve all the project names into their release groups, and check
     * that individual projects are not found in multiple groups.
     */
    const releaseGroups = {};
    const alreadyMatchedProjects = new Set();
    for (const [releaseGroupName, releaseGroup] of Object.entries(groups)) {
        // Ensure that the config for the release group can resolve at least one project
        const matchingProjects = (0, find_matching_projects_1.findMatchingProjects)(releaseGroup.projects, projectGraph.nodes);
        if (!matchingProjects.length) {
            return {
                error: {
                    code: 'RELEASE_GROUP_MATCHES_NO_PROJECTS',
                    data: {
                        releaseGroupName: releaseGroupName,
                    },
                },
                nxReleaseConfig: null,
            };
        }
        // If provided, ensure release tag pattern is valid
        if (releaseGroup.releaseTagPattern) {
            const error = ensureReleaseGroupReleaseTagPatternIsValid(releaseGroup.releaseTagPattern, releaseGroupName);
            if (error) {
                return {
                    error,
                    nxReleaseConfig: null,
                };
            }
        }
        for (const project of matchingProjects) {
            if (alreadyMatchedProjects.has(project)) {
                return {
                    error: {
                        code: 'PROJECT_MATCHES_MULTIPLE_GROUPS',
                        data: {
                            project,
                        },
                    },
                    nxReleaseConfig: null,
                };
            }
            alreadyMatchedProjects.add(project);
        }
        // First apply any group level defaults, then apply actual root level config (if applicable), then group level config
        const groupChangelogDefaults = [GROUP_DEFAULTS.changelog];
        if (rootChangelogConfig.projectChangelogs) {
            groupChangelogDefaults.push(rootChangelogConfig.projectChangelogs);
        }
        const projectsRelationship = releaseGroup.projectsRelationship || GROUP_DEFAULTS.projectsRelationship;
        if (releaseGroup.changelog) {
            releaseGroup.changelog = normalizeTrueToEmptyObject(releaseGroup.changelog);
        }
        const groupDefaults = {
            projectsRelationship,
            projects: matchingProjects,
            version: deepMergeDefaults(
            // First apply any group level defaults, then apply actual root level config, then group level config
            [GROUP_DEFAULTS.version, rootVersionWithoutGit], releaseGroup.version),
            // If the user has set any changelog config at all, including at the root level, then use one set of defaults, otherwise default to false for the whole feature
            changelog: releaseGroup.changelog || rootChangelogConfig.projectChangelogs
                ? deepMergeDefaults(groupChangelogDefaults, releaseGroup.changelog || {})
                : false,
            releaseTagPattern: releaseGroup.releaseTagPattern ||
                // The appropriate group default releaseTagPattern is dependent upon the projectRelationships
                (projectsRelationship === 'independent'
                    ? defaultIndependentReleaseTagPattern
                    : userConfig.releaseTagPattern || defaultFixedReleaseTagPattern),
        };
        const finalReleaseGroup = deepMergeDefaults([groupDefaults], {
            ...releaseGroup,
            // Ensure that the resolved project names take priority over the original user config (which could have contained unresolved globs etc)
            projects: matchingProjects,
        });
        // Apply conventionalCommits shorthand to the final group if explicitly configured in the original group
        if (releaseGroup.version?.conventionalCommits === true) {
            finalReleaseGroup.version.generatorOptions = {
                ...finalReleaseGroup.version.generatorOptions,
                currentVersionResolver: 'git-tag',
                specifierSource: 'conventional-commits',
            };
        }
        if (releaseGroup.version?.conventionalCommits === false &&
            releaseGroupName !== exports.IMPLICIT_DEFAULT_RELEASE_GROUP) {
            delete finalReleaseGroup.version.generatorOptions.currentVersionResolver;
            delete finalReleaseGroup.version.generatorOptions.specifierSource;
        }
        releaseGroups[releaseGroupName] = finalReleaseGroup;
    }
    return {
        error: null,
        nxReleaseConfig: {
            projectsRelationship: WORKSPACE_DEFAULTS.projectsRelationship,
            releaseTagPattern: WORKSPACE_DEFAULTS.releaseTagPattern,
            git: rootGitConfig,
            version: rootVersionConfig,
            changelog: rootChangelogConfig,
            groups: releaseGroups,
        },
    };
}
exports.createNxReleaseConfig = createNxReleaseConfig;
/**
 * In some cases it is much cleaner and more intuitive for the user to be able to
 * specify `true` in their config when they want to use the default config for a
 * particular property, rather than having to specify an empty object.
 */
function normalizeTrueToEmptyObject(value) {
    return value === true ? {} : value;
}
async function handleNxReleaseConfigError(error) {
    switch (error.code) {
        case 'PROJECTS_AND_GROUPS_DEFINED':
            {
                const nxJsonMessage = await (0, resolve_nx_json_error_message_1.resolveNxJsonConfigErrorMessage)([
                    'release',
                    'projects',
                ]);
                devkit_exports_1.output.error({
                    title: `"projects" is not valid when explicitly defining release groups, and everything should be expressed within "groups" in that case. If you are using "groups" then you should remove the "projects" property`,
                    bodyLines: [nxJsonMessage],
                });
            }
            break;
        case 'RELEASE_GROUP_MATCHES_NO_PROJECTS':
            {
                const nxJsonMessage = await (0, resolve_nx_json_error_message_1.resolveNxJsonConfigErrorMessage)([
                    'release',
                    'groups',
                ]);
                devkit_exports_1.output.error({
                    title: `Release group "${error.data.releaseGroupName}" matches no projects. Please ensure all release groups match at least one project:`,
                    bodyLines: [nxJsonMessage],
                });
            }
            break;
        case 'PROJECT_MATCHES_MULTIPLE_GROUPS':
            {
                const nxJsonMessage = await (0, resolve_nx_json_error_message_1.resolveNxJsonConfigErrorMessage)([
                    'release',
                    'groups',
                ]);
                devkit_exports_1.output.error({
                    title: `Project "${error.data.project}" matches multiple release groups. Please ensure all projects are part of only one release group:`,
                    bodyLines: [nxJsonMessage],
                });
            }
            break;
        case 'RELEASE_GROUP_RELEASE_TAG_PATTERN_VERSION_PLACEHOLDER_MISSING_OR_EXCESSIVE':
            {
                const nxJsonMessage = await (0, resolve_nx_json_error_message_1.resolveNxJsonConfigErrorMessage)([
                    'release',
                    'groups',
                    error.data.releaseGroupName,
                    'releaseTagPattern',
                ]);
                devkit_exports_1.output.error({
                    title: `Release group "${error.data.releaseGroupName}" has an invalid releaseTagPattern. Please ensure the pattern contains exactly one instance of the "{version}" placeholder`,
                    bodyLines: [nxJsonMessage],
                });
            }
            break;
        case 'CONVENTIONAL_COMMITS_SHORTHAND_MIXED_WITH_OVERLAPPING_GENERATOR_OPTIONS':
            {
                const nxJsonMessage = await (0, resolve_nx_json_error_message_1.resolveNxJsonConfigErrorMessage)([
                    'release',
                ]);
                devkit_exports_1.output.error({
                    title: `You have configured both the shorthand "version.conventionalCommits" and one or more of the related "version.generatorOptions" that it sets for you. Please use one or the other:`,
                    bodyLines: [nxJsonMessage],
                });
            }
            break;
        case 'GLOBAL_GIT_CONFIG_MIXED_WITH_GRANULAR_GIT_CONFIG':
            {
                const nxJsonMessage = await (0, resolve_nx_json_error_message_1.resolveNxJsonConfigErrorMessage)([
                    'release',
                    'git',
                ]);
                devkit_exports_1.output.error({
                    title: `You have duplicate conflicting git configurations. If you are using the top level 'nx release' command, then remove the 'release.version.git' and 'release.changelog.git' properties in favor of 'release.git'. If you are using the subcommands or the programmatic API, then remove the 'release.git' property in favor of 'release.version.git' and 'release.changelog.git':`,
                    bodyLines: [nxJsonMessage],
                });
            }
            break;
        default:
            throw new Error(`Unhandled error code: ${error.code}`);
    }
    process.exit(1);
}
exports.handleNxReleaseConfigError = handleNxReleaseConfigError;
function ensureReleaseGroupReleaseTagPatternIsValid(releaseTagPattern, releaseGroupName) {
    // ensure that any provided releaseTagPattern contains exactly one instance of {version}
    return releaseTagPattern.split('{version}').length === 2
        ? null
        : {
            code: 'RELEASE_GROUP_RELEASE_TAG_PATTERN_VERSION_PLACEHOLDER_MISSING_OR_EXCESSIVE',
            data: {
                releaseGroupName,
            },
        };
}
function ensureProjectsConfigIsArray(groups) {
    const result = {};
    for (const [groupName, groupConfig] of Object.entries(groups)) {
        result[groupName] = {
            ...groupConfig,
            projects: ensureArray(groupConfig.projects),
        };
    }
    return result;
}
function ensureArray(value) {
    return Array.isArray(value) ? value : [value];
}
function isObject(value) {
    return value && typeof value === 'object' && !Array.isArray(value);
}
// Helper function to merge two config objects
function mergeConfig(objA, objB) {
    const merged = { ...objA };
    for (const key in objB) {
        if (objB.hasOwnProperty(key)) {
            // If objB[key] is explicitly set to false, null or 0, respect that value
            if (objB[key] === false || objB[key] === null || objB[key] === 0) {
                merged[key] = objB[key];
            }
            // If both objA[key] and objB[key] are objects, recursively merge them
            else if (isObject(merged[key]) && isObject(objB[key])) {
                merged[key] = mergeConfig(merged[key], objB[key]);
            }
            // If objB[key] is defined, use it (this will overwrite any existing value in merged[key])
            else if (objB[key] !== undefined) {
                merged[key] = objB[key];
            }
        }
    }
    return merged;
}
/**
 * This function takes in a strictly typed collection of all possible default values in a particular section of config,
 * and an optional set of partial user config, and returns a single, deeply merged config object, where the user
 * config takes priority over the defaults in all cases (only an `undefined` value in the user config will be
 * overwritten by the defaults, all other falsey values from the user will be respected).
 */
function deepMergeDefaults(defaultConfigs, userConfig) {
    let result;
    // First merge defaultConfigs sequentially (meaning later defaults will override earlier ones)
    for (const defaultConfig of defaultConfigs) {
        if (!result) {
            result = defaultConfig;
            continue;
        }
        result = mergeConfig(result, defaultConfig);
    }
    // Finally, merge the userConfig
    if (userConfig) {
        result = mergeConfig(result, userConfig);
    }
    return result;
}
/**
 * We want to prevent users from setting both the conventionalCommits shorthand and any of the related
 * generatorOptions at the same time, since it is at best redundant, and at worst invalid.
 */
function hasInvalidConventionalCommitsConfig(userConfig) {
    // at the root
    if (userConfig.version?.conventionalCommits === true &&
        (userConfig.version?.generatorOptions?.currentVersionResolver ||
            userConfig.version?.generatorOptions?.specifierSource)) {
        return true;
    }
    // within any groups
    if (userConfig.groups) {
        for (const group of Object.values(userConfig.groups)) {
            if (group.version?.conventionalCommits === true &&
                (group.version?.generatorOptions?.currentVersionResolver ||
                    group.version?.generatorOptions?.specifierSource)) {
                return true;
            }
        }
    }
    return false;
}
/**
 * We want to prevent users from setting both the global and granular git configurations. Users should prefer the
 * global configuration if using the top level nx release command and the granular configuration if using
 * the subcommands or the programmatic API.
 */
function hasInvalidGitConfig(userConfig) {
    return (!!userConfig.git && !!(userConfig.version?.git || userConfig.changelog?.git));
}
