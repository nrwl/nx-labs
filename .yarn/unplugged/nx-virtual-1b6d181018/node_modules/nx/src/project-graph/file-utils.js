"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.workspaceLayout = exports.readNxJson = exports.readPackageJson = exports.defaultFileRead = exports.readWorkspaceConfig = exports.TEN_MEGABYTES = exports.calculateFileChanges = exports.isDeletedFileChange = exports.isWholeFileChange = exports.DeletedFileChange = exports.WholeFileChange = void 0;
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const path_1 = require("path");
const configuration_1 = require("../config/configuration");
const workspace_root_1 = require("../utils/workspace-root");
const fileutils_1 = require("../utils/fileutils");
const json_diff_1 = require("../utils/json-diff");
const project_graph_1 = require("./project-graph");
const angular_json_1 = require("../adapter/angular-json");
const ignore_1 = require("../utils/ignore");
const retrieve_workspace_files_1 = require("./utils/retrieve-workspace-files");
const project_configuration_utils_1 = require("./utils/project-configuration-utils");
const nx_plugin_deprecated_1 = require("../utils/nx-plugin.deprecated");
const minimatch_1 = require("minimatch");
const package_json_next_to_project_json_1 = require("../plugins/project-json/build-nodes/package-json-next-to-project-json");
class WholeFileChange {
    constructor() {
        this.type = 'WholeFileChange';
    }
}
exports.WholeFileChange = WholeFileChange;
class DeletedFileChange {
    constructor() {
        this.type = 'WholeFileDeleted';
    }
}
exports.DeletedFileChange = DeletedFileChange;
function isWholeFileChange(change) {
    return change.type === 'WholeFileChange';
}
exports.isWholeFileChange = isWholeFileChange;
function isDeletedFileChange(change) {
    return change.type === 'WholeFileDeleted';
}
exports.isDeletedFileChange = isDeletedFileChange;
function calculateFileChanges(files, allWorkspaceFiles, nxArgs, readFileAtRevision = defaultReadFileAtRevision, ignore = (0, ignore_1.getIgnoreObject)()) {
    files = files.filter((f) => !ignore.ignores(f));
    return files.map((f) => {
        const ext = (0, path_1.extname)(f);
        const file = allWorkspaceFiles.find((fileData) => fileData.file == f);
        const hash = file?.hash;
        return {
            file: f,
            ext,
            hash,
            getChanges: () => {
                if (!(0, fs_1.existsSync)((0, path_1.join)(workspace_root_1.workspaceRoot, f))) {
                    return [new DeletedFileChange()];
                }
                if (!nxArgs) {
                    return [new WholeFileChange()];
                }
                if (nxArgs.files && nxArgs.files.includes(f)) {
                    return [new WholeFileChange()];
                }
                switch (ext) {
                    case '.json':
                        try {
                            const atBase = readFileAtRevision(f, nxArgs.base);
                            const atHead = readFileAtRevision(f, nxArgs.head);
                            return (0, json_diff_1.jsonDiff)(JSON.parse(atBase), JSON.parse(atHead));
                        }
                        catch (e) {
                            return [new WholeFileChange()];
                        }
                    default:
                        return [new WholeFileChange()];
                }
            },
        };
    });
}
exports.calculateFileChanges = calculateFileChanges;
exports.TEN_MEGABYTES = 1024 * 10000;
function defaultReadFileAtRevision(file, revision) {
    try {
        const fileFullPath = `${workspace_root_1.workspaceRoot}${path_1.sep}${file}`;
        const gitRepositoryPath = (0, child_process_1.execSync)('git rev-parse --show-toplevel')
            .toString()
            .trim();
        const filePathInGitRepository = (0, path_1.relative)(gitRepositoryPath, fileFullPath)
            .split(path_1.sep)
            .join('/');
        return !revision
            ? (0, fs_1.readFileSync)(file, 'utf-8')
            : (0, child_process_1.execSync)(`git show ${revision}:${filePathInGitRepository}`, {
                maxBuffer: exports.TEN_MEGABYTES,
                stdio: ['pipe', 'pipe', 'ignore'],
            })
                .toString()
                .trim();
    }
    catch {
        return '';
    }
}
/**
 * TODO(v19): Remove this function
 * @deprecated To get projects use {@link retrieveProjectConfigurations} instead
 */
function readWorkspaceConfig(opts) {
    let configuration = null;
    const root = opts.path || process.cwd();
    const nxJson = (0, configuration_1.readNxJson)(root);
    try {
        const projectGraph = (0, project_graph_1.readCachedProjectGraph)();
        configuration = {
            ...nxJson,
            ...(0, project_graph_1.readProjectsConfigurationFromProjectGraph)(projectGraph),
        };
    }
    catch {
        configuration = {
            version: 2,
            projects: getProjectsSyncNoInference(root, nxJson).projects,
        };
    }
    if (opts.format === 'angularCli') {
        return (0, angular_json_1.toOldFormat)(configuration);
    }
    else {
        return configuration;
    }
}
exports.readWorkspaceConfig = readWorkspaceConfig;
function defaultFileRead(filePath) {
    return (0, fs_1.readFileSync)((0, path_1.join)(workspace_root_1.workspaceRoot, filePath), 'utf-8');
}
exports.defaultFileRead = defaultFileRead;
function readPackageJson() {
    try {
        return (0, fileutils_1.readJsonFile)(`${workspace_root_1.workspaceRoot}/package.json`);
    }
    catch {
        return {}; // if package.json doesn't exist
    }
}
exports.readPackageJson = readPackageJson;
// TODO(17): Remove these exports
var configuration_2 = require("../config/configuration");
Object.defineProperty(exports, "readNxJson", { enumerable: true, get: function () { return configuration_2.readNxJson; } });
Object.defineProperty(exports, "workspaceLayout", { enumerable: true, get: function () { return configuration_2.workspaceLayout; } });
/**
 * TODO(v19): Remove this function.
 */
function getProjectsSyncNoInference(root, nxJson) {
    const projectFiles = (0, retrieve_workspace_files_1.retrieveProjectConfigurationPaths)(root, (0, nx_plugin_deprecated_1.getDefaultPluginsSync)(root));
    const plugins = [
        { plugin: package_json_next_to_project_json_1.PackageJsonProjectsNextToProjectJsonPlugin },
        ...(0, nx_plugin_deprecated_1.getDefaultPluginsSync)(root),
    ];
    const projectRootMap = new Map();
    // We iterate over plugins first - this ensures that plugins specified first take precedence.
    for (const { plugin, options } of plugins) {
        const [pattern, createNodes] = plugin.createNodes ?? [];
        if (!pattern) {
            continue;
        }
        for (const file of projectFiles) {
            if ((0, minimatch_1.minimatch)(file, pattern, { dot: true })) {
                let r = createNodes(file, options, {
                    nxJsonConfiguration: nxJson,
                    workspaceRoot: root,
                });
                for (const node in r.projects) {
                    const project = {
                        root: node,
                        ...r.projects[node],
                    };
                    (0, project_configuration_utils_1.mergeProjectConfigurationIntoRootMap)(projectRootMap, project);
                }
            }
        }
    }
    return {
        projects: (0, project_configuration_utils_1.readProjectConfigurationsFromRootMap)(projectRootMap),
    };
}
