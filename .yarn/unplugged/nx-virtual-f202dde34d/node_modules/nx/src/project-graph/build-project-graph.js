"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildProjectGraphUsingProjectFileMap = exports.getFileMap = void 0;
const workspace_root_1 = require("../utils/workspace-root");
const path_1 = require("path");
const perf_hooks_1 = require("perf_hooks");
const assert_workspace_validity_1 = require("../utils/assert-workspace-validity");
const nx_deps_cache_1 = require("./nx-deps-cache");
const implicit_project_dependencies_1 = require("./utils/implicit-project-dependencies");
const normalize_project_nodes_1 = require("./utils/normalize-project-nodes");
const nx_plugin_1 = require("../utils/nx-plugin");
const typescript_1 = require("../plugins/js/utils/typescript");
const fileutils_1 = require("../utils/fileutils");
const project_graph_builder_1 = require("./project-graph-builder");
const configuration_1 = require("../config/configuration");
const fs_1 = require("fs");
const installation_directory_1 = require("../utils/installation-directory");
const output_1 = require("../utils/output");
let storedFileMap = null;
let storedAllWorkspaceFiles = null;
let storedRustReferences = null;
function getFileMap() {
    if (!!storedFileMap) {
        return {
            fileMap: storedFileMap,
            allWorkspaceFiles: storedAllWorkspaceFiles,
            rustReferences: storedRustReferences,
        };
    }
    else {
        return {
            fileMap: {
                nonProjectFiles: [],
                projectFileMap: {},
            },
            allWorkspaceFiles: [],
            rustReferences: null,
        };
    }
}
exports.getFileMap = getFileMap;
async function buildProjectGraphUsingProjectFileMap(projects, externalNodes, fileMap, allWorkspaceFiles, rustReferences, fileMapCache, shouldWriteCache) {
    storedFileMap = fileMap;
    storedAllWorkspaceFiles = allWorkspaceFiles;
    storedRustReferences = rustReferences;
    const nxJson = (0, configuration_1.readNxJson)();
    const projectGraphVersion = '6.0';
    (0, assert_workspace_validity_1.assertWorkspaceValidity)(projects, nxJson);
    const packageJsonDeps = readCombinedDeps();
    const rootTsConfig = readRootTsConfig();
    let filesToProcess;
    let cachedFileData;
    const useCacheData = fileMapCache &&
        !(0, nx_deps_cache_1.shouldRecomputeWholeGraph)(fileMapCache, packageJsonDeps, projects, nxJson, rootTsConfig);
    if (useCacheData) {
        const fromCache = (0, nx_deps_cache_1.extractCachedFileData)(fileMap, fileMapCache);
        filesToProcess = fromCache.filesToProcess;
        cachedFileData = fromCache.cachedFileData;
    }
    else {
        filesToProcess = fileMap;
        cachedFileData = {
            nonProjectFiles: {},
            projectFileMap: {},
        };
    }
    const context = createContext(projects, nxJson, externalNodes, fileMap, filesToProcess);
    let projectGraph = await buildProjectGraphUsingContext(nxJson, externalNodes, context, cachedFileData, projectGraphVersion);
    const projectFileMapCache = (0, nx_deps_cache_1.createProjectFileMapCache)(nxJson, packageJsonDeps, fileMap, rootTsConfig);
    if (shouldWriteCache) {
        (0, nx_deps_cache_1.writeCache)(projectFileMapCache, projectGraph);
    }
    return {
        projectGraph,
        projectFileMapCache,
    };
}
exports.buildProjectGraphUsingProjectFileMap = buildProjectGraphUsingProjectFileMap;
function readCombinedDeps() {
    const installationPackageJsonPath = (0, path_1.join)(workspace_root_1.workspaceRoot, '.nx', 'installation', 'package.json');
    const installationPackageJson = (0, fs_1.existsSync)(installationPackageJsonPath)
        ? (0, fileutils_1.readJsonFile)(installationPackageJsonPath)
        : {};
    const rootPackageJsonPath = (0, path_1.join)(workspace_root_1.workspaceRoot, 'package.json');
    const rootPackageJson = (0, fs_1.existsSync)(rootPackageJsonPath)
        ? (0, fileutils_1.readJsonFile)(rootPackageJsonPath)
        : {};
    return {
        ...rootPackageJson.dependencies,
        ...rootPackageJson.devDependencies,
        ...installationPackageJson.dependencies,
        ...installationPackageJson.devDependencies,
    };
}
async function buildProjectGraphUsingContext(nxJson, knownExternalNodes, ctx, cachedFileData, projectGraphVersion) {
    perf_hooks_1.performance.mark('build project graph:start');
    const builder = new project_graph_builder_1.ProjectGraphBuilder(null, ctx.fileMap.projectFileMap);
    builder.setVersion(projectGraphVersion);
    for (const node in knownExternalNodes) {
        builder.addExternalNode(knownExternalNodes[node]);
    }
    await (0, normalize_project_nodes_1.normalizeProjectNodes)(ctx, builder);
    const initProjectGraph = builder.getUpdatedProjectGraph();
    const r = await updateProjectGraphWithPlugins(ctx, initProjectGraph);
    const updatedBuilder = new project_graph_builder_1.ProjectGraphBuilder(r, ctx.fileMap.projectFileMap);
    for (const proj of Object.keys(cachedFileData.projectFileMap)) {
        for (const f of ctx.fileMap.projectFileMap[proj] || []) {
            const cached = cachedFileData.projectFileMap[proj][f.file];
            if (cached && cached.deps) {
                f.deps = [...cached.deps];
            }
        }
    }
    for (const file of ctx.fileMap.nonProjectFiles) {
        const cached = cachedFileData.nonProjectFiles[file.file];
        if (cached?.deps) {
            file.deps = [...cached.deps];
        }
    }
    (0, implicit_project_dependencies_1.applyImplicitDependencies)(ctx.projects, updatedBuilder);
    const finalGraph = updatedBuilder.getUpdatedProjectGraph();
    perf_hooks_1.performance.mark('build project graph:end');
    perf_hooks_1.performance.measure('build project graph', 'build project graph:start', 'build project graph:end');
    return finalGraph;
}
function createContext(projects, nxJson, externalNodes, fileMap, filesToProcess) {
    const clonedProjects = Object.keys(projects).reduce((map, projectName) => {
        map[projectName] = {
            ...projects[projectName],
        };
        return map;
    }, {});
    return {
        nxJsonConfiguration: nxJson,
        projects: clonedProjects,
        externalNodes,
        workspaceRoot: workspace_root_1.workspaceRoot,
        fileMap,
        filesToProcess,
    };
}
async function updateProjectGraphWithPlugins(context, initProjectGraph) {
    const plugins = await (0, nx_plugin_1.loadNxPlugins)(context.nxJsonConfiguration?.plugins, (0, installation_directory_1.getNxRequirePaths)(), context.workspaceRoot, context.projects);
    let graph = initProjectGraph;
    for (const { plugin } of plugins) {
        try {
            if ((0, nx_plugin_1.isNxPluginV1)(plugin) &&
                plugin.processProjectGraph &&
                !plugin.createDependencies) {
                output_1.output.warn({
                    title: `${plugin.name} is a v1 plugin.`,
                    bodyLines: [
                        'Nx has recently released a v2 model for project graph plugins. The `processProjectGraph` method is deprecated. Plugins should use some combination of `createNodes` and `createDependencies` instead.',
                    ],
                });
                perf_hooks_1.performance.mark(`${plugin.name}:processProjectGraph - start`);
                graph = await plugin.processProjectGraph(graph, {
                    ...context,
                    projectsConfigurations: {
                        projects: context.projects,
                        version: 2,
                    },
                    fileMap: context.fileMap.projectFileMap,
                    filesToProcess: context.filesToProcess.projectFileMap,
                    workspace: {
                        version: 2,
                        projects: context.projects,
                        ...context.nxJsonConfiguration,
                    },
                });
                perf_hooks_1.performance.mark(`${plugin.name}:processProjectGraph - end`);
                perf_hooks_1.performance.measure(`${plugin.name}:processProjectGraph`, `${plugin.name}:processProjectGraph - start`, `${plugin.name}:processProjectGraph - end`);
            }
        }
        catch (e) {
            let message = `Failed to process the project graph with "${plugin.name}".`;
            if (e instanceof Error) {
                e.message = message + '\n' + e.message;
                throw e;
            }
            throw new Error(message);
        }
    }
    const builder = new project_graph_builder_1.ProjectGraphBuilder(graph, context.fileMap.projectFileMap, context.fileMap.nonProjectFiles);
    const createDependencyPlugins = plugins.filter(({ plugin }) => (0, nx_plugin_1.isNxPluginV2)(plugin) && plugin.createDependencies);
    await Promise.all(createDependencyPlugins.map(async ({ plugin, options }) => {
        perf_hooks_1.performance.mark(`${plugin.name}:createDependencies - start`);
        // Set this globally to allow plugins to know if they are being called from the project graph creation
        global.NX_GRAPH_CREATION = true;
        try {
            const dependencies = await plugin.createDependencies(options, {
                ...context,
            });
            for (const dep of dependencies) {
                builder.addDependency(dep.source, dep.target, dep.type, 'sourceFile' in dep ? dep.sourceFile : null);
            }
        }
        catch (e) {
            let message = `Failed to process project dependencies with "${plugin.name}".`;
            if (e instanceof Error) {
                e.message = message + '\n' + e.message;
                throw e;
            }
            throw new Error(message);
        }
        delete global.NX_GRAPH_CREATION;
        perf_hooks_1.performance.mark(`${plugin.name}:createDependencies - end`);
        perf_hooks_1.performance.measure(`${plugin.name}:createDependencies`, `${plugin.name}:createDependencies - start`, `${plugin.name}:createDependencies - end`);
    }));
    return builder.getUpdatedProjectGraph();
}
function readRootTsConfig() {
    try {
        const tsConfigPath = (0, typescript_1.getRootTsConfigPath)();
        if (tsConfigPath) {
            return (0, fileutils_1.readJsonFile)(tsConfigPath, { expectComments: true });
        }
    }
    catch (e) {
        return {};
    }
}
